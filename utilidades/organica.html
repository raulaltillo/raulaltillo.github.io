<!DOCTYPE html>
<html lang="es">
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-T470HXGPQZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-T470HXGPQZ');
</script>
  <meta charset="utf-8" />
  <title>Organica | Raulaltillo</title>
  <link rel="icon" href="../favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="../main.css">
  <style>
    :root{ --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --muted:#9ca3af; --accent:#22d3ee; --ok:#22c55e; --err:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      color:var(--ink);
      background:#1a1a1a;
      font-family: Arial, Helvetica, sans-serif;
    }
    .app{ 
      width:100%; 
      max-width:1000px; 
      background:#2d2d2d; 
      backdrop-filter: blur(6px);
      border:solid 15px #0b0b0b; 
      border-radius:10px; 
      padding:24px; 
      margin: 20px auto;
    }
    h1{ margin:0 0 8px; font-weight:800; letter-spacing:.2px; font-family: Hacked; }
    .sub{ color:var(--muted); margin-bottom:24px }
    .grid{ display:grid; grid-template-columns:1fr 1fr; gap:16px }
    .card{ background:#2d2d2d; border:solid 15px #0b0b0b; border-radius:10px; padding:16px }
    .label{ color:#e0e0e0; font-size:12px; text-transform:uppercase; letter-spacing:.08em; font-family: Hacked }
    .big{ font-size:24px; font-weight:700; margin:4px 0 0 }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace }
    input[type=text]{ width:100%; padding:12px 14px; border-radius:12px; border:1px solid #000000; background:#1a1a1a; color:#e0e0e0 }
    input[type=text]::placeholder{ color:#6b7280 }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .btn{ appearance:none; border:none; background:#2D7A5E; color:#e0e0e0; font-weight:800; padding:12px 16px; border-radius:12px; cursor:pointer; transition:background-color 0.3s }
    .btn:hover{ background-color:#1e5542 }
    .btn.secondary{ background:#3d3d3d; color:#e0e0e0 }
    .note{ color:#e0e0e0; font-size:13px }
    .badge{ display:inline-block; padding:4px 8px; border-radius:999px; font-size:12px; background:#1a1a1a; border:1px solid #1f2937; color:#e0e0e0 }
    .status{ margin-top:8px; font-weight:700 }
    .ok{ color:#22c55e }
    .bad{ color:#ef4444 }
    .hint{ color:#e0e0e0 }
    .footer{ margin-top:16px; display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap }
    .switch{ display:inline-flex; align-items:center; gap:8px; cursor:pointer; user-select:none }
    .switch input{ display:none }
    .pill{ width:42px; height:24px; background:#3d3d3d; border-radius:999px; position:relative; transition:background .2s }
    .pill::after{ content:""; position:absolute; top:2px; left:2px; width:20px; height:20px; border-radius:50%; background:#e5e7eb; transition:transform .2s }
    .switch input:checked + .pill{ background:var(--accent) }
    .switch input:checked + .pill::after{ transform:translateX(18px) }
    .tiny{ font-size:12px }
    .kbd{ font-size:12px; border:1px solid #374151; background:#1a1a1a; padding:.2em .45em; border-radius:6px }
  </style>
</head>
<body>
  <div class="topnav">
    <img class="title" id="weather-icon" src="../images/weather-icon-illustration03-Graphics-10205167-1.png" alt="Clima actual" width="50px">
    <a href="../pages/horario.html">Horario</a>
    <a href="../pages/menu.html">Menu</a>
    <a href="../pages/selectividad.html">Selectividad</a>
    <a href="../pages/herramientas.html" class="active">Herramientas</a>
    <a href="https://docs.google.com/forms/d/e/1FAIpQLSdnBjqzIB08Ad6J5D6hyBe0z33kqKwkunFWNIXyWWmJCmnFjw/viewform?usp=sf_link" class="feedback-btn">Feedback</a>
  </div>

  <div id="weatherIframeContainer" class="weather-iframe-container">
    <iframe name="iframe_aemet_id33044" src="https://www.aemet.es/es/eltiempo/prediccion/municipios/mostrarwidget/jerez-de-la-frontera-id11020?w=g4p011100000ohmffffffx000000t999999r1s8n2" scrolling="no"></iframe>
  </div>
  <div id="content">
    <br><br><br>
    <div class="app">
      <h1>Formulacion organica IUPAC</h1>

    <div class="grid">
      <div class="card">
        <div class="label">Formula semidesarrollada</div>
        <div id="semi" class="big mono">—</div>
      </div>
      <div class="card">
        <div class="label">Datos</div>
        <div class="row" style="gap:8px; margin-top:6px">
          <span class="badge" id="badgeFam">Familia: <span id="familia">—</span></span>
          <span class="badge" id="badgeFor">Fórmula: <span id="formula">—</span></span>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:16px">
      <div class="label">Tu respuesta</div>
      <div class="row" style="margin-top:6px">
        <input id="answer" type="text" placeholder="Ej.: 4-bromo-2,3-dimetilhex-2-eno / butanona / 2-propanol" />
        <button id="checkBtn" class="btn">Comprobar <span class="kbd">Enter</span></button>
        <button id="skipBtn" class="btn secondary" title="Nueva molécula (no puntúa)">Saltar</button>
      </div>
      <div id="status" class="status hint">—</div>
      <div id="reveal" class="note" style="display:none"></div>
    </div>

    <div class="footer">
      <div class="row tiny hint">
        <span id="score">Aciertos: 0/0</span>
      </div>
      <div class="row tiny hint">
        <label class="switch" title="Mostrar/ocultar la familia">
          <input id="showFam" type="checkbox"><span class="pill"></span><span>Mostrar familia</span>
        </label>
        <label class="switch" title="Mostrar/ocultar la fórmula molecular">
          <input id="showFor" type="checkbox"><span class="pill"></span><span>Mostrar fórmula</span>
        </label>
      </div>
    </div>
  </div>

  <script>
    /* ===========================
       Utilidades básicas y datos
       =========================== */
    const $ = (sel)=>document.querySelector(sel);

    const PREFIJOS = {1:"met",2:"et",3:"prop",4:"but",5:"pent",6:"hex",7:"hept",8:"oct",9:"non",10:"dec"};
    const ROOT = (n)=>PREFIJOS[n] || `C${n}`;

    // Sustituyentes disponibles como prefijos (cuando NO son grupo principal)
    // clave -> {nombre, alphaKey} (alphaKey ignora prefijos multiplicativos)
    const SUBS_TYPES = {
      metil:  {name:"metil",  alpha:"metil"},
      etil:   {name:"etil",   alpha:"etil"},
      fluoro: {name:"fluoro", alpha:"fluoro"},
      cloro:  {name:"cloro",  alpha:"cloro"},
      bromo:  {name:"bromo",  alpha:"bromo"},
      iodo:   {name:"iodo",   alpha:"iodo"},
      nitro:  {name:"nitro",  alpha:"nitro"},
      hidroxi:{name:"hidroxi",alpha:"hidroxi"},
      amino:  {name:"amino",  alpha:"amino"},
      metoxi: {name:"metoxi", alpha:"alcoxi-metoxi"},
      etoxi:  {name:"etoxi",  alpha:"alcoxi-etoxi"},
    };
    const MULTI_PREFIX = (k)=> (k===2?'di':k===3?'tri':k===4?'tetra':k===5?'penta':k===6?'hexa':`x${k}`);

    const rint = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const choice = (arr)=>arr[Math.floor(Math.random()*arr.length)];

    function normalizeName(s){
      return s.toLowerCase()
        .replaceAll(/[–—]/g,"-")
        .normalize('NFD').replace(/[\u0300-\u036f]/g,"") // sin acentos
        .replace(/\s+/g,"-")
        .replace(/,{2,}/g,",")
        .replace(/-{2,}/g,"-")
        .replace(/^-|-$|\.|,/g,"");
    }

    // Orden alfabético de prefijos ignorando multiplicativos (di-, tri- no cuentan)
    function alphaKeyOf(type){ return SUBS_TYPES[type]?.alpha || type; }

    /* =========================================
       Modelo simplificado de molécula lineal
       - n: número de C en cadena principal
       - fg: grupo principal (string) o null
       - posFG: locante(s) del grupo principal
       - db: posiciones de dobles (i -> entre i e i+1)
       - tb: posiciones de triples
       - subs: [{pos, type}]  (pueden repetirse tipos/posiciones)
       ========================================= */

    // Familias principales soportadas (según PDF: ácidos > nitrilos > aldehídos > cetonas > alcoholes > aminas > (éteres como sustituyentes) > insaturación > alcanos)
    const FAMILIAS = ["acido","nitrilo","aldehido","cetona","alcohol","amina","alqueno","alquino","alcano","halogenuro","nitro"];

    // Generadores de estructuras
    function genCadena(nMin=2,nMax=9){ return rint(nMin,nMax); }

    function genUnsat(n, minPos = 1){
    // a lo sumo UNA insaturación
    const t = choice(["none","ene","ino","ene","none"]);
    if(t === "none") return { db: [], tb: [] };
    const pos = rint(minPos, Math.max(minPos, n-1));
    return t === "ene" ? { db: [pos], tb: [] } : { db: [], tb: [pos] };
    }


    function genSustituyentes(n, fg){
      // de 0 a 3 sustituyentes (evitando C1 si es ácido/nitrilo/aldehido)
      const count = rint(0,3);
      const pool = Object.keys(SUBS_TYPES).filter(t=>{
        if(fg==="alcohol" && t==="hidroxi") return false;
        if(fg==="amina" && t==="amino") return false;
        return true;
      });
      const out = [];
      for(let i=0;i<count;i++){
        const type = choice(pool);
        let p = rint(1,n);
        if((fg==="acido"||fg==="nitrilo"||fg==="aldehido") && p===1) p = n>1?2:1; // no colgar en el C del sufijo principal
        out.push({pos:p, type});
      }
      return out;
    }

    function genMolecula(){
      // Escoge familia y construye coherentemente
      const fam = choice(FAMILIAS);
      let n = genCadena(2,9);
      let fg = null, posFG=[], db=[], tb=[], subs=[], formula="";

      if(fam==="acido"){
        n = genCadena(1,8);
        fg="acido"; posFG=[1]; ({db,tb}={db:[],tb:[]}); subs = []; // sin subs para simplificar
        formula = n===1? "CH2O2" : `C${n}H${2*n}O2`;
      } else if(fam==="nitrilo"){
        n = genCadena(2,9);
        fg="nitrilo"; posFG=[1]; ({db,tb}={db:[],tb:[]}); subs = genSustituyentes(n, fg);
        formula = `C${n}H${2*n-1}N`;
      } else if(fam==="aldehido"){
        n = genCadena(2,9);
        fg="aldehido"; posFG=[1];
        ({db,tb}=genUnsat(n, 2)); // <— mínimo 2, no tocar C1
        subs = genSustituyentes(n, fg);
        formula = `C${n}H${2*n}O`; // aprox

      } else if(fam==="cetona"){
        n = genCadena(3,9);
        fg="cetona"; posFG=[ rint(2, n-1) ]; ({db,tb}={db:[],tb:[]}); subs = genSustituyentes(n, fg);
        formula = `C${n}H${2*n}O`;
      } else if(fam==="alcohol"){
        n = genCadena(1,9);
        fg="alcohol"; posFG=[ n===1?1:rint(1,n) ]; ({db,tb}=genUnsat(n)); subs = genSustituyentes(n, fg);
        formula = `C${n}H${2*n+2}O`;
      } else if(fam==="amina"){
        n = genCadena(1,9);
        fg="amina"; posFG=[ n===1?1:rint(1,n) ]; ({db,tb}=genUnsat(n)); subs = genSustituyentes(n, fg);
        formula = `C${n}H${2*n+3}N`;
      } else if(fam==="alqueno"){
        n = genCadena(2,9);
        ({db,tb}=genUnsat(n)); if(db.length===0){ db=[rint(1,n-1)]; tb=[]; } // aseguramos doble
        subs = genSustituyentes(n, null); formula = `C${n}H${2*n}`;
      } else if(fam==="alquino"){
        n = genCadena(2,9);
        ({db,tb}=genUnsat(n)); if(tb.length===0){ tb=[rint(1,n-1)]; db=[]; } // aseguramos triple
        subs = genSustituyentes(n, null); formula = `C${n}H${2*n-2}`;
      } else if(fam==="halogenuro"){
        n = genCadena(2,9);
        fg=null; ({db,tb}={db:[],tb:[]});
        // al menos 1 halógeno
        let k = rint(1,3);
        subs = [];
        while(k--) subs.push({pos:rint(1,n), type:choice(["fluoro","cloro","bromo","iodo"])});
        subs = subs.concat(genSustituyentes(n, null));
        formula = `C${n}H${2*n+2}`; // aproximada
      } else if(fam==="nitro"){
        n = genCadena(2,9);
        fg=null; ({db,tb}=genUnsat(n)); // nitro sólo como prefijo
        let k=rint(1,2); subs=[];
        while(k--) subs.push({pos:rint(1,n), type:"nitro"});
        subs = subs.concat(genSustituyentes(n, null));
        formula = `C${n}H${2*n+2}N${subs.filter(s=>s.type==='nitro').length}`; // aprox
      } else { // alcano
        n = genCadena(1,10);
        fg=null; ({db,tb}={db:[],tb:[]}); subs = genSustituyentes(n, null);
        formula = `C${n}H${2*n+2}`;
      }

      return {n, fg, posFG, db, tb, subs, formula};
    }

    /* =====================================
       Orientación (menor conjunto de locantes)
       - compara izquierda→derecha vs derecha→izquierda
       - prioridad: grupo principal > dobles > triples > sustituyentes
       - si hay empate en insaturaciones, se prioriza el doble (PDF)
       ===================================== */
    function mirrorPos(n,p){ return n+1-p; }
    function mirrorList(n,arr){ return arr.map(p=>mirrorPos(n,p)).sort((a,b)=>a-b); }
    function mirrorBonds(n,arr){ return arr.map(p=>(n-p)).sort((a,b)=>a-b); } // dobles/triples entre i e i+1

    function orientationKey(mol, flip){
      const n = mol.n;
      const fg = mol.fg;
      let fgLoc = [];
      if(fg==="acido"||fg==="nitrilo"||fg==="aldehido"){ fgLoc=[1]; }
      else if(fg==="cetona"||fg==="alcohol"||fg==="amina"){ fgLoc = flip? mirrorList(n, mol.posFG): [...mol.posFG].sort((a,b)=>a-b); }
      else fgLoc=[];

      const dLoc = flip? mirrorBonds(n, mol.db): [...mol.db].sort((a,b)=>a-b);
      const tLoc = flip? mirrorBonds(n, mol.tb): [...mol.tb].sort((a,b)=>a-b);

      const sLoc = (flip? mol.subs.map(s=>mirrorPos(n,s.pos)) : mol.subs.map(s=>s.pos)).sort((a,b)=>a-b);

      return [fgLoc, dLoc, tLoc, sLoc];
    }
    function lexLess(a,b){
      // compara dos arrays de arrays lexicográficamente
      const L = Math.min(a.length,b.length);
      for(let i=0;i<L;i++){
        const x=a[i], y=b[i];
        for(let j=0;j<Math.min(x.length,y.length);j++){
          if(x[j]!==y[j]) return x[j]<y[j];
        }
        if(x.length!==y.length) return x.length<y.length;
      }
      return false;
    }

    function orient(mol){
    const n = mol.n;
    const anchorFG = (mol.fg === "acido" || mol.fg === "nitrilo" || mol.fg === "aldehido");

    // Si el FG es terminal, fuerza C1 en el lado del FG
    if(anchorFG){
        if(mol.posFG[0] !== 1){
        // aplicar espejo una vez
        const subs = mol.subs.map(s=>({pos:n+1-s.pos, type:s.type}));
        const posFG = mol.posFG.map(p=>n+1-p);
        const db = mol.db.map(p=>(n-p)).sort((a,b)=>a-b);
        const tb = mol.tb.map(p=>(n-p)).sort((a,b)=>a-b);
        return {...mol, subs, posFG, db, tb, flipped:true};
        }
        return {...mol, flipped:false};
    }

    // Si no es FG terminal, usa la comparación lexicográfica original
    const keyL = orientationKey(mol,false);
    const keyR = orientationKey(mol,true);
    const useR = lexLess(keyR, keyL);
    if(!useR) return {...mol, flipped:false};
    const subs = mol.subs.map(s=>({pos:n+1-s.pos, type:s.type}));
    const posFG = mol.posFG.map(p=>n+1-p);
    const db = mol.db.map(p=>(n-p)).sort((a,b)=>a-b);
    const tb = mol.tb.map(p=>(n-p)).sort((a,b)=>a-b);
    return {...mol, subs, posFG, db, tb, flipped:true};
    }


    /* =============================
       Semidesarrolladas (C1 a izq.)
       ============================= */
    function semiBase(n){
      if(n===1) return ["CH3"];
      if(n===2) return ["CH3","CH3"];
      return ["CH3", ...Array(n-2).fill("CH2"), "CH3"];
    }
    function addBranch(frag, idx, tag){ // convierte CH3/CH2/CHOH en CH(...ramas)
      let f = frag[idx];
      if(f==="CH3"||f==="CH2"||f==="CHOH"||f==="CH2OH") f="CH";
      frag[idx] = f + tag;
    }

    function semiString(m){
    const {n, fg, posFG, db, tb, subs} = m;
    let fr = semiBase(n);

    if(fg==="acido"){
        if(n===1) return "H-COOH";
        return "CH3-"+(n===2?"":"CH2-".repeat(n-2)).replace(/-$/,"")+"-COOH";
    }
    if(fg==="nitrilo"){
        const cola = (n>=2? ("-CH3"+(n>=3? "-"+Array(n-2).fill("CH2").join("-"):"")) : "");
        return "NC"+(cola? "-"+cola : "");
    }
    if(fg==="aldehido"){
        if(n===1) return "H-CHO";
        // No devolvemos aún: colocamos CHO en C1 y seguimos para insertar =/≡ si toca
        fr[0] = "CHO";
    }
    if(fg==="cetona"){
        const p = posFG[0];
        const left = p, right = n-p;
        const parts = [];
        if(left===1){ parts.push("CO"); }
        else if(left===2){ parts.push("CH3","-","CO"); }
        else { parts.push("CH3"); for(let i=0;i<left-2;i++) parts.push("-","CH2"); parts.push("-","CO"); }
        if(right>=1){
        if(right===1) parts.push("-","CH3");
        else { parts.push("-","CH2"); for(let i=0;i<right-2;i++) parts.push("-","CH2"); parts.push("-","CH3"); }
        }
        // en cetonas ya ensamblamos string completo
        const s = parts.join("");
        // (por simplicidad no añadimos sustituyentes visualmente aquí)
        return s;
    }
    if(fg==="alcohol"){
        const p = posFG[0]-1;
        if(n===1) return "CH3-OH";
        fr[p] = (p===0||p===n-1) ? "CH2OH" : "CHOH";
    }
    if(fg==="amina"){
        const p = posFG[0]-1;
        fr[p] = (fr[p]==="CH3"||fr[p]==="CH2") ? "CH(NH2)" : (fr[p]+"(NH2)");
    }

    // Insaturaciones (una)
    if(db.length && fr.length>1){
        const i = db[0];
        const parts=[]; for(let k=0;k<n;k++){ parts.push(fr[k]); if(k===i-1) parts.push("="); else if(k<n-1) parts.push("-"); }
        return parts.join("");
    } else if(tb.length && fr.length>1){
        const i = tb[0];
        const parts=[]; for(let k=0;k<n;k++){ parts.push(fr[k]); if(k===i-1) parts.push("≡"); else if(k<n-1) parts.push("-"); }
        return parts.join("");
    }

    // Sustituyentes simples en la cadena (visual)
    subs.forEach(({pos,type})=>{
        const idx = pos-1;
        const tag = (type==="metil")?"(CH3)":
                    (type==="etil")?"(CH2CH3)":
                    (type==="metoxi")?"(OCH3)":
                    (type==="etoxi")?"(OCH2CH3)":
                    (type==="hidroxi")?"(OH)":
                    (type==="amino")?"(NH2)":
                    (type==="fluoro")?"(F)":
                    (type==="cloro")?"(Cl)":
                    (type==="bromo")?"(Br)":
                    (type==="iodo")?"(I)":
                    (type==="nitro")?"(NO2)":"";
        if(tag){ addBranch(fr, idx, tag); }
    });
    return fr.join("-");
    }


    /* =========================
       Construcción del nombre
       ========================= */
    function locantsToString(locs){ return locs.sort((a,b)=>a-b).join(","); }

    function groupSubstituents(subs){
      // agrupamos por tipo -> {type: [pos,...]}
      const map = {};
      subs.forEach(s=>{
        if(!map[s.type]) map[s.type]=[];
        map[s.type].push(s.pos);
      });
      // ordenar posiciones y formatear con multiplicativos
      const entries = Object.entries(map).map(([type, locs])=>{
        locs.sort((a,b)=>a-b);
        const k = locs.length;
        const pref = (k>1? MULTI_PREFIX(k):"");
        const name = SUBS_TYPES[type].name;
        const head = locs.join(",");
        return {
          type,
          alpha: alphaKeyOf(type),
          text: `${head}-${pref?pref:""}${name}`
        };
      });
      // ordenar por alfa (ignorando multi)
      entries.sort((a,b)=> a.alpha.localeCompare(b.alpha));
      return entries.map(e=>e.text).join("-");
    }

    function nombreBaseConInsat(n, db, tb){
      // una sola insaturación como asumimos en generador
      if(db.length===0 && tb.length===0) return ROOT(n)+"ano";
      if(db.length===1 && tb.length===0) return `${ROOT(n)}-${db[0]}-eno`;
      if(tb.length===1 && db.length===0) return `${ROOT(n)}-${tb[0]}-ino`;
      // mixto (raro aquí), usamos en/ino
      const en = db.length? `${db.join(",")}-en` : "";
      const yn = tb.length? `${tb.join(",")}-in` : "";
      const sep = en&&yn ? "-" : "";
      return `${ROOT(n)}-${en}${sep}${yn}o`;
    }

    function nombrePrincipal(m){
    const {n, fg, posFG, db, tb} = m;

    if(fg==="acido")   return `acido ${ROOT(n)}anoico`;
    if(fg==="nitrilo") return `${ROOT(n)}onitrilo`; // simplificado

    if(fg==="aldehido"){
        // si hay insaturación: ...-enal / ...-inal
        if(db.length===1 && tb.length===0){
        return `${ROOT(n)}-${db[0]}-enal`;
        }
        if(tb.length===1 && db.length===0){
        return `${ROOT(n)}-${tb[0]}-inal`;
        }
        // saturado
        return `${ROOT(n)}anal`;
    }

    if(fg==="cetona"){
        const unico = (n===3)||(n===4);
        const p = posFG[0];
        return unico? `${ROOT(n)}anona` : `${ROOT(n)}an-${p}-ona`;
    }

    if(fg==="alcohol"){
        if(n<=2) return `${ROOT(n)}anol`;
        return `${ROOT(n)}an-${posFG[0]}-ol`;
    }

    if(fg==="amina"){
        if(n<=2) return `${ROOT(n)}anamina`;
        return `${ROOT(n)}an-${posFG[0]}-amina`;
    }

    // hidrocarburos
    if(db.length || tb.length) return nombreBaseConInsat(n, db, tb);
    return `${ROOT(n)}ano`;
    }


    function nombreCompleto(m){
      // 1) orientar para LCML
      m = orient(m);

      // 2) nombre principal (cadena)
      const base = nombrePrincipal(m);

      // 3) prefijos de sustituyentes (si m.fg no "acido" con restricción)
      const pref = m.subs.length? groupSubstituents(m.subs) : "";

      // 4) juntar
      return pref ? `${pref}-${base}` : base;
    }

    // Variantes aceptadas: forma antigua (2-buteno) y sin locante cuando único (ya contemplado en base)
    function altForm(nombre){
    let s = nombre;
    // but-2-eno -> 2-buteno ; propan-2-ol -> 2-propanol ; butan-2-ona -> 2-butanona
    s = s.replace(/^(.+?)-(\d+)-(eno|ino)$/, (_,$1,$2,$3)=> `${$2}-${$1}${$3}`);
    s = s.replace(/^(.*?)([a-z]+)an-(\d+)-ol$/, (_,$1,$2,$3)=> `${$3}-${$1}${$2}anol`);
    s = s.replace(/^([a-z]+)an-(\d+)-ona$/, (_,$1,$2)=> `${$2}-${$1}anona`);
    // hex-2-enal -> 2-hexenal ; hex-3-inal -> 3-hexinal
    s = s.replace(/^(.+?)-(\d+)-enal$/, (_,$1,$2)=> `${$2}-${$1}enal`);
    s = s.replace(/^(.+?)-(\d+)-inal$/, (_,$1,$2)=> `${$2}-${$1}inal`);
    return s;
    }


    /* =========================
       Fórmula molecular simple
       ========================= */
    function formulaMol(m){
      if(m.fg==="acido") return m.formula;
      if(m.fg==="nitrilo") return m.formula;
      if(m.fg==="aldehido") return m.formula;
      if(m.fg==="cetona") return m.formula;
      if(m.fg==="alcohol") return m.formula;
      if(m.fg==="amina") return m.formula;
      // hidrocarburos/halógenos/nitro aprox
      return m.formula;
    }

    /* =========================
       Quiz (lógica de teclado)
       ========================= */

    // Estado del juego (siguiendo tu patrón de Enter)
    let esperandoSiguiente = false;
    let aciertos = 0;
    let preguntas = 0;

    // Estado de molécula actual
    let MOL = null;

    function actualizarMarcador(){
      $("#score").textContent = `Aciertos: ${aciertos}/${preguntas}`;
    }

    function renderMolecula(){
      const semi = semiString(MOL);
      $("#semi").textContent = semi;
      $("#familia").textContent = MOL.fg ? MOL.fg : (MOL.db.length?"alqueno": MOL.tb.length?"alquino":"alcano");
      $("#formula").textContent = formulaMol(MOL);
      $("#status").className = "status hint";
      $("#status").textContent = "Escribe el nombre IUPAC y pulsa Enter.";
      $("#reveal").style.display = "none";
      $("#answer").value = "";
      $("#answer").focus();
      // visibilidad
      $("#badgeFam").style.display = $("#showFam").checked ? "inline-block":"none";
      $("#badgeFor").style.display = $("#showFor").checked ? "inline-block":"none";
    }

    function nuevaPregunta(){
      esperandoSiguiente = false;
      MOL = genMolecula();
      MOL = orient(MOL);
      renderMolecula();
      $("#checkBtn").textContent = "Comprobar";
    }

    function nombresAceptados(m){
      const canonical = nombreCompleto(m);
      const alt = altForm(canonical);
      const set = new Set();
      set.add(normalizeName(canonical));
      set.add(normalizeName(alt));
      // casos sin locante único (ya en canonical si aplica)
      return set;
    }

    function comprobar(){
      if(esperandoSiguiente){
        nuevaPregunta();
        return;
      }
      const entradaRaw = $("#answer").value.trim();
      if(!entradaRaw){
        $("#status").className = "status hint";
        $("#status").textContent = "Escribe un nombre.";
        return;
      }
      const entrada = normalizeName(entradaRaw);
      const aceptados = nombresAceptados(MOL);

      preguntas += 1;
      if(aceptados.has(entrada)){
        aciertos += 1;
        $("#status").className = "status ok";
        $("#status").textContent = `✅ ¡Correcto! ${Array.from(aceptados)[0]}. Pulsa Enter para continuar.`;
        $("#reveal").style.display = "block";
        $("#reveal").textContent = `Solución canónica: ${nombreCompleto(MOL)}`;
        esperandoSiguiente = true;
        $("#checkBtn").textContent = "Siguiente";
      } else {
        $("#status").className = "status bad";
        $("#status").textContent = `❌ Incorrecto. Pulsa Enter para continuar.`;
        $("#reveal").style.display = "block";
        $("#reveal").textContent = `Solución: ${nombreCompleto(MOL)}`;
        esperandoSiguiente = true;
        $("#checkBtn").textContent = "Siguiente";
      }
      actualizarMarcador();
    }

    /* ====== Eventos ====== */
    $("#checkBtn").addEventListener("click", comprobar);
    $("#skipBtn").addEventListener("click", nuevaPregunta);
    $("#answer").addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        comprobar();
      }
    });
    $("#showFam").addEventListener("change", ()=>{ $("#badgeFam").style.display = $("#showFam").checked ? "inline-block":"none"; });
    $("#showFor").addEventListener("change", ()=>{ $("#badgeFor").style.display = $("#showFor").checked ? "inline-block":"none"; });

    // Arranque
    nuevaPregunta();
  </script>
  </div>
  <script async src="../scripts/fade.js"></script>
</body>
</html>
